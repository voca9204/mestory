import { useState, useEffect, useRef, useMemo, useCallback } from 'react'
import { format, startOfYear, endOfYear, eachDayOfInterval, isSameDay, getDayOfYear } from 'date-fns'
import { useData } from '../contexts/DataContext'
import { Timeline2DProps, TooltipData, DragState, Offset } from './Timeline2DTypes'
import { Timeline2DTooltip } from './Timeline2DTooltip'
import { Timeline2DLegend } from './Timeline2DLegend'
import { Timeline2DControls } from './Timeline2DControls'
import { Timeline2DHeader } from './Timeline2DHeader'
import { Timeline2DDateCell } from './Timeline2DDateCell'
import { Timeline2DUsageGuide } from './Timeline2DUsageGuide'
import { Timeline2DYearIndicator } from './Timeline2DYearIndicator'
import { Timeline2DSelectedInfo } from './Timeline2DSelectedInfo'
import { Timeline2DLoadingIndicator } from './Timeline2DLoadingIndicator'
import { useTimeline2DData } from './useTimeline2DData'
import { 
  calculateTooltipPosition, 
  getMonthBoundaries, 
  isWeekend,
  DEFAULT_GRID_CONFIG,
  NAVIGATION,
  CANVAS_CONFIG 
} from './Timeline2DUtils'
export function Timeline2D({ selectedDate, onDateSelect }: Timeline2DProps) {
  const { isUsingMockData } = useData()
  const [currentYear, setCurrentYear] = useState(new Date().getFullYear())
  const [scale, setScale] = useState(2)
  const [dragState, setDragState] = useState<DragState>({ isDragging: false, lastX: 0, lastY: 0 })
  const [offset, setOffset] = useState<Offset>({ x: 0, y: 0 })
  const [isInitialized, setIsInitialized] = useState(false)
  
  const {
    yearDataCache,
    loadingYears,
    hasDataForDate,
    loadDiaryForTooltip,
    loadVisibleYears,
    loadYearData,
    clearCache
  } = useTimeline2DData()
  
  const [tooltipData, setTooltipData] = useState<TooltipData | null>(null)
  const [isLoadingTooltip, setIsLoadingTooltip] = useState(false)
  const [hoveredDate, setHoveredDate] = useState<Date | null>(null)
  const tooltipTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  
  const containerRef = useRef<HTMLDivElement>(null)
  const todayCellRef = useRef<HTMLDivElement>(null)
  const cellSize = DEFAULT_GRID_CONFIG.cellSize * scale
  const gapSize = DEFAULT_GRID_CONFIG.gapSize
  const monthLabels = DEFAULT_GRID_CONFIG.monthLabels
  const currentYearNum = new Date().getFullYear()
  const years = useMemo(() => {
    const startYear = currentYearNum - 5
    const endYear = currentYearNum + 10
    return Array.from({ length: endYear - startYear + 1 }, (_, i) => startYear + i)
  }, [currentYearNum])
  const maxDaysInYear = DEFAULT_GRID_CONFIG.maxDaysInYear
  const [isAnimating, setIsAnimating] = useState(false)
  const handleDateMouseEnter = useCallback((date: Date, event: React.MouseEvent) => {
    const hasData = hasDataForDate(date)
    const isDragging = dragState.isDragging
    
    if (!hasData || isDragging) {
      return
    }
    
    setHoveredDate(date)
    
    // Ïù¥Ï†Ñ ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (tooltipTimeoutRef.current) {
      clearTimeout(tooltipTimeoutRef.current)
    }
    // ÎßàÏö∞Ïä§ ÏúÑÏπò Í≥ÑÏÇ∞ (Ïª®ÌÖåÏù¥ÎÑà Í∏∞Ï§Ä, Ïä§ÏºÄÏùºÍ≥º Ïò§ÌîÑÏÖã Í≥†Î†§)
    if (containerRef.current) {
      const containerRect = containerRef.current.getBoundingClientRect()
      const mousePosition = {
        x: event.clientX - containerRect.left,
        y: event.clientY - containerRect.top
      }
      console.log('üñ±Ô∏è ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏:', {
        ÎÇ†Ïßú: format(date, 'M/d'), 
        ÎßàÏö∞Ïä§Ï¢åÌëú: `(${event.clientX}, ${event.clientY})`,
        Ïª®ÌÖåÏù¥ÎÑàÏ¢åÌëú: `(${mousePosition.x}, ${mousePosition.y})`,
        ÏùºÍ∏∞ÏûàÏùå: hasData
      })
      // 300ms ÌõÑÏóê Ìà¥ÌåÅ ÌëúÏãú (ÎîîÎ∞îÏö¥Ïä§)
      tooltipTimeoutRef.current = setTimeout(async () => {
        setIsLoadingTooltip(true)
        try {
          const diary = await loadDiaryForTooltip(date)
          if (hoveredDate && isSameDay(hoveredDate, date)) {
            setTooltipData({
              date,
              diary,
              position: mousePosition
            })
          }
        } catch (error) {
          console.error('ÏùºÍ∏∞ Î°úÎî© Ïã§Ìå®:', error)
        } finally {
          setIsLoadingTooltip(false)
        }
      }, 300)
    }
  }, [hasDataForDate, dragState.isDragging, loadDiaryForTooltip])
  const handleDateMouseLeave = useCallback(() => {
    setHoveredDate(null)
    setTooltipData(null)
    
    if (tooltipTimeoutRef.current) {
      clearTimeout(tooltipTimeoutRef.current)
      tooltipTimeoutRef.current = null
    }
  }, [])
  const calculateVisibleYears = useCallback(() => {
    if (!containerRef.current) return []
    
    const containerRect = containerRef.current.getBoundingClientRect()
    const containerHeight = containerRect.height
    
    const padding = 32
    const headerHeight = 26
    const yearRowHeight = cellSize + gapSize
    
    const topY = (-offset.y) / scale
    const bottomY = (-offset.y + containerHeight) / scale
    
    const startYearIndex = Math.max(0, Math.floor((topY - padding - headerHeight) / yearRowHeight) - 1)
    const endYearIndex = Math.min(years.length - 1, Math.ceil((bottomY - padding - headerHeight) / yearRowHeight) + 1)
    
    // Í∞ÄÏãú ÏòÅÏó≠Ïùò Ïó∞ÎèÑÎì§ Î∞òÌôò
    const visibleYears = []
    for (let i = startYearIndex; i <= endYearIndex; i++) {
      if (i >= 0 && i < years.length) {
        visibleYears.push(years[i])
      }
    }
    return visibleYears
  }, [offset.y, scale, cellSize, gapSize, years])
  useEffect(() => {
    const timer = setTimeout(() => {
      const visibleYears = calculateVisibleYears()
      loadVisibleYears(visibleYears)
    }, 200) // 200ms ÎîîÎ∞îÏö¥Ïä§
    
    return () => clearTimeout(timer)
  }, [offset, scale, calculateVisibleYears, loadVisibleYears])
  useEffect(() => {
    if (isInitialized) {
      const currentYearNum = new Date().getFullYear()
      // ÌòÑÏû¨ Ïó∞ÎèÑÎßå ÎØ∏Î¶¨ Î°úÎî©
      loadYearData(currentYearNum)
    }
  }, [isInitialized, loadYearData])
  const updateCurrentViewYear = useCallback(() => {
    if (!containerRef.current) return
    
    const containerRect = containerRef.current.getBoundingClientRect()
    const containerCenterY = containerRect.height / 2
    
    const padding = 32
    const headerHeight = 26
    
    const actualCenterY = (containerCenterY - offset.y) / scale
    const yearRowHeight = cellSize + gapSize
    const yearIndex = Math.round((actualCenterY - padding - headerHeight) / yearRowHeight)
    
    if (yearIndex >= 0 && yearIndex < years.length) {
      const viewYear = years[yearIndex]
      if (viewYear !== currentYear) {
        setCurrentYear(viewYear)
      }
    }
  }, [offset.y, scale, cellSize, gapSize, years, currentYear])
  useEffect(() => {
    const timer = setTimeout(() => {
      updateCurrentViewYear()
    }, 100)
    
    return () => clearTimeout(timer)
  }, [offset, scale])
  // Ï¥àÍ∏∞ ÏúÑÏπò ÏÑ§Ï†ï
  useEffect(() => {
    if (!isInitialized && containerRef.current) {
      const today = new Date()
      
      if (!selectedDate) {
        onDateSelect(today)
      }
      
      setCurrentYear(today.getFullYear())
      setIsAnimating(true)
      setScale(2.0)
      
      const performCenterOnToday = () => {
        if (!containerRef.current) return
        
        const today = new Date()
        const todayYear = today.getFullYear()
        const todayDayOfYear = getDayOfYear(today)
        const yearIndex = years.findIndex(year => year === todayYear)
        
        if (yearIndex !== -1) {
          const containerRect = containerRef.current.getBoundingClientRect()
          const containerCenterX = containerRect.width / 2
          const containerHeight = containerRect.height
          
          const padding = 32
          const headerHeight = 26
          const yearLabelWidth = 64
          const currentCellSize = 12 * 2.0
          const currentGapSize = 1
          
          const cellX = yearLabelWidth + padding + (todayDayOfYear - 1) * (currentCellSize + currentGapSize) + currentCellSize/2
          const cellY = padding + headerHeight + yearIndex * (currentCellSize + currentGapSize) + currentCellSize/2
          const targetY = containerHeight * 0.33
          
          const targetOffsetX = containerCenterX - cellX * 2.5
          const targetOffsetY = targetY - cellY * 2.5
          
          setOffset({
            x: targetOffsetX,
            y: targetOffsetY
          })
        }
      }
      
      setTimeout(() => {
        performCenterOnToday()
      }, 100)
      
      setTimeout(() => {
        performCenterOnToday()
        setIsInitialized(true)
        setIsAnimating(false)
      }, 500)
    }
  }, [isInitialized, selectedDate, onDateSelect, years])
  // Ïò§ÎäòÎ°ú Ïù¥Îèô
  const goToToday = useCallback(() => {
    const today = new Date()
    setIsAnimating(true)
    setCurrentYear(today.getFullYear())
    onDateSelect(today)
    
    if (scale < 2 || scale > 4) {
      setScale(3)
    }
    
    setTimeout(() => {
      if (containerRef.current) {
        const today = new Date()
        const todayYear = today.getFullYear()
        const todayDayOfYear = getDayOfYear(today)
        const yearIndex = years.findIndex(year => year === todayYear)
        
        if (yearIndex !== -1) {
          const containerRect = containerRef.current.getBoundingClientRect()
          const containerCenterX = containerRect.width / 2
          const containerHeight = containerRect.height
          
          const padding = 32
          const headerHeight = 26
          const yearLabelWidth = 64
          const currentCellSize = 12 * scale
          const currentGapSize = 1
          
          const cellX = yearLabelWidth + padding + (todayDayOfYear - 1) * (currentCellSize + currentGapSize) + currentCellSize/2
          const cellY = padding + headerHeight + yearIndex * (currentCellSize + currentGapSize) + currentCellSize/2
          const targetY = containerHeight * 0.33
          
          const targetOffsetX = containerCenterX - cellX * scale
          const targetOffsetY = targetY - cellY * scale
          
          setOffset({
            x: targetOffsetX,
            y: targetOffsetY
          })
        }
      }
      
      setTimeout(() => {
        setIsAnimating(false)
      }, 150)
    }, 50)
  }, [onDateSelect, years, scale])
  // ÎìúÎûòÍ∑∏ Ìï∏Îì§Îü¨
  const handleMouseDown = (e: React.MouseEvent) => {
    setIsAnimating(false)
    setTooltipData(null) // ÎìúÎûòÍ∑∏ ÏãúÏûëÌïòÎ©¥ Ìà¥ÌåÅ Ïà®ÍπÄ
    setDragState({
      isDragging: true,
      lastX: e.clientX,
      lastY: e.clientY
    })
  }
  const handleMouseMove = (e: React.MouseEvent) => {
    if (!dragState.isDragging) return
    const deltaX = (e.clientX - dragState.lastX) * 0.8
    const deltaY = (e.clientY - dragState.lastY) * 0.8
    setOffset(prev => ({
      x: prev.x + deltaX,
      y: prev.y + deltaY
    }))
    setDragState(prev => ({
      ...prev,
      lastX: e.clientX,
      lastY: e.clientY
    }))
  }
  const handleMouseUp = () => {
    setDragState(prev => ({ ...prev, isDragging: false }))
  }
  // Î≤ÑÌäº Í∏∞Î∞ò ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
  const moveStep = 100
  const moveLeft = () => setOffset(prev => ({ ...prev, x: prev.x + moveStep }))
  const moveRight = () => setOffset(prev => ({ ...prev, x: prev.x - moveStep }))
  const moveUp = () => setOffset(prev => ({ ...prev, y: prev.y + moveStep }))
  const moveDown = () => setOffset(prev => ({ ...prev, y: prev.y - moveStep }))
  const zoomIn = () => setScale(prev => Math.min(4, prev * 1.2))
  const zoomOut = () => setScale(prev => Math.max(1.5, prev / 1.2))
  // Ïó∞ÎèÑ Îã®ÏúÑ Ïù¥Îèô
  const moveToYear = (targetYear: number) => {
    const yearIndex = years.findIndex(year => year === targetYear)
    if (yearIndex === -1) return
    
    if (!containerRef.current) return
    const containerRect = containerRef.current.getBoundingClientRect()
    const containerHeight = containerRect.height
    
    const padding = 32
    const headerHeight = 26
    const cellY = padding + headerHeight + yearIndex * (cellSize + gapSize) + cellSize/2
    const targetY = containerHeight * 0.33
    const targetOffsetY = targetY - cellY * scale
    
    setIsAnimating(true)
    setOffset(prev => ({ ...prev, y: targetOffsetY }))
    setCurrentYear(targetYear)
    
    setTimeout(() => setIsAnimating(false), 300)
  }
  // Ìú† Ï§å Ìï∏Îì§Îü¨
  const handleWheel = (e: React.WheelEvent) => {
    e.preventDefault()
    const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05
    setScale(prev => Math.max(1.5, Math.min(4, prev * zoomFactor)))
  }
  // ÎÇ†Ïßú ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
  const handleDateClick = (date: Date) => {
    setTooltipData(null) // ÌÅ¥Î¶≠ Ïãú Ìà¥ÌåÅ Ïà®ÍπÄ
    onDateSelect(date)
  }
  // ÌäπÏ†ï ÎÇ†ÏßúÍ∞Ä ÏÑ†ÌÉùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
  const isDateSelected = (date: Date) => {
    return selectedDate ? isSameDay(date, selectedDate) : false
  }
  // ÏõîÎ≥Ñ Íµ¨Î∂ÑÏÑ† ÏúÑÏπò Í≥ÑÏÇ∞
  const getMonthBoundaries = (year: number) => {
    const boundaries = []
    for (let month = 0; month < 12; month++) {
      const firstDay = new Date(year, month, 1)
      const dayOfYear = getDayOfYear(firstDay)
      boundaries.push(dayOfYear - 1)
    }
    return boundaries
  }
  // üéØ NEW: Ìà¥ÌåÅ ÏúÑÏπò Í≥ÑÏÇ∞ (ÌôîÎ©¥ Í≤ΩÍ≥Ñ Í≥†Î†§) - Fixed ÏúÑÏπòÏö©
  const calculateTooltipPosition = (basePosition: { x: number, y: number }) => {
    if (!containerRef.current) return basePosition
    
    const containerRect = containerRef.current.getBoundingClientRect()
    const tooltipWidth = 320
    const tooltipHeight = 250 // Ï¢Ä Îçî ÎÜíÍ≤å ÏÑ§Ï†ï
    const padding = 20
    
    // Ïª®ÌÖåÏù¥ÎÑà ÏÉÅÎåÄ ÏúÑÏπòÎ•º ÌôîÎ©¥ Ï†àÎåÄ ÏúÑÏπòÎ°ú Î≥ÄÌôò
    const screenX = containerRect.left + basePosition.x
    const screenY = containerRect.top + basePosition.y
    
    let x = screenX + 15 // ÎßàÏö∞Ïä§ÏóêÏÑú ÏïΩÍ∞Ñ Ïò§Î•∏Ï™Ω
    let y = screenY - tooltipHeight - 10 // ÎßàÏö∞Ïä§ ÏúÑÏ™Ω
    
    // Ïò§Î•∏Ï™Ω Í≤ΩÍ≥Ñ ÌôïÏù∏ (Ï†ÑÏ≤¥ ÌôîÎ©¥ Í∏∞Ï§Ä)
    if (x + tooltipWidth > window.innerWidth - padding) {
      x = screenX - tooltipWidth - 15
    }
    
    // ÏúÑÏ™Ω Í≤ΩÍ≥Ñ ÌôïÏù∏
    if (y < padding) {
      y = screenY + 25 // ÎßàÏö∞Ïä§ ÏïÑÎûòÏ™ΩÏúºÎ°ú Ïù¥Îèô
    }
    
    // ÏïÑÎûòÏ™Ω Í≤ΩÍ≥Ñ ÌôïÏù∏
    if (y + tooltipHeight > window.innerHeight - padding) {
      y = window.innerHeight - tooltipHeight - padding
    }
    
    // ÏôºÏ™Ω Í≤ΩÍ≥Ñ ÌôïÏù∏
    if (x < padding) {
      x = padding
    }
    
    return { x: Math.max(0, x), y: Math.max(0, y) }
  }
  return (
    <div className="relative w-full h-[500px] overflow-hidden border border-gray-200 rounded-lg bg-gray-50">
      {/* Î°úÎî© ÏÉÅÌÉú ÌëúÏãú */}
      <Timeline2DLoadingIndicator loadingYears={loadingYears} />
      {/* ÌòÑÏû¨ Î≥¥Í≥† ÏûàÎäî ÎÖÑÎèÑ ÌëúÏãú */}
      <Timeline2DYearIndicator currentYear={currentYear} />
      {/* Ïª®Ìä∏Î°§ Ìå®ÎÑê */}
      <Timeline2DControls
        currentYear={currentYear}
        scale={scale}
        hoveredDate={hoveredDate}
        tooltipData={tooltipData}
        isLoadingTooltip={isLoadingTooltip}
        yearDataCacheSize={yearDataCache.size}
        totalDatesCount={Array.from(yearDataCache.values()).reduce((sum, dateSet) => sum + dateSet.size, 0)}
        diaryCacheSize={0} // diaryCacheÍ∞Ä useTimeline2DData ÎÇ¥Î∂ÄÏóê ÏûàÏùå
        onGoToToday={goToToday}
        onRefresh={() => {
          clearCache()
          setTooltipData(null)
        }}
        onMoveUp={moveUp}
        onMoveDown={moveDown}
        onMoveLeft={moveLeft}
        onMoveRight={moveRight}
        onZoomIn={zoomIn}
        onZoomOut={zoomOut}
        onMoveToYear={moveToYear}
      />
      {/* ÏÇ¨Ïö©Î≤ï ÏïàÎÇ¥ */}
      <Timeline2DUsageGuide />
      {/* Ìà¥ÌåÅ Ïª¥Ìè¨ÎÑåÌä∏ */}
      <Timeline2DTooltip
        tooltipData={tooltipData}
        isLoadingTooltip={isLoadingTooltip}
        hoveredDate={hoveredDate}
        calculateTooltipPosition={calculateTooltipPosition}
      />
      {/* 2D ÌÉÄÏûÑÎùºÏù∏ Í∑∏Î¶¨Îìú */}
      <div
        ref={containerRef}
        className={`w-full h-full cursor-grab active:cursor-grabbing ${
          isAnimating ? 'transition-transform duration-300 ease-out' : ''
        }`}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={() => {
          handleMouseUp()
          handleDateMouseLeave()
        }}
        onWheel={handleWheel}
        style={{
          transform: `translate(${offset.x}px, ${offset.y}px) scale(${scale})`,
          transformOrigin: '0 0'
        }}
      >
        <div className="p-8">
          {/* Ïõî ÎùºÎ≤® (ÏàòÌèâ ÏÉÅÎã®) */}
          <Timeline2DHeader
            cellSize={cellSize}
            gapSize={gapSize}
            maxDaysInYear={maxDaysInYear}
            monthLabels={monthLabels}
            getMonthBoundaries={getMonthBoundaries}
          />
          {/* Ïó∞ÎèÑÎ≥Ñ Ïó¥ */}
          {years.map((year, yearIndex) => {
            const isCurrentYear = year === new Date().getFullYear()
            const yearDates = eachDayOfInterval({
              start: startOfYear(new Date(year, 0, 1)),
              end: endOfYear(new Date(year, 0, 1))
            })
            
            return (
              <div key={year} className="flex items-start mb-1">
                {/* Ïó∞ÎèÑ ÎùºÎ≤® */}
                <div 
                  className={`w-16 text-xs font-medium text-right pr-2 py-1 border-r-2 border-gray-400 shadow-sm ${
                    isCurrentYear ? 'text-white font-bold bg-blue-600' : 'text-gray-700 bg-gray-100'
                  }`}
                  style={{ 
                    height: `${cellSize + gapSize}px`,
                    position: 'sticky',
                    left: '0',
                    zIndex: 25
                  }}
                >
                  {year}
                </div>
                {/* ÎÇ†Ïßú Í∑∏Î¶¨Îìú */}
                <div className="flex">
                  {Array.from({ length: maxDaysInYear }, (_, dayIndex) => {
                    const date = yearDates[dayIndex]
                    
                    if (!date) {
                      return (
                        <div
                          key={dayIndex}
                          style={{
                            width: `${cellSize}px`,
                            height: `${cellSize}px`,
                            marginRight: `${gapSize}px`,
                          }}
                        />
                      )
                    }
                    const isSelected = isDateSelected(date)
                    const hasData = hasDataForDate(date)
                    const isToday = isSameDay(date, new Date())
                    const weekend = isWeekend(date)
                    const isHovered = hoveredDate && isSameDay(hoveredDate, date)
                    
                    return (
                      <Timeline2DDateCell
                        key={dayIndex}
                        ref={isToday ? todayCellRef : undefined}
                        date={date}
                        dayIndex={dayIndex}
                        cellSize={cellSize}
                        gapSize={gapSize}
                        hasData={hasData}
                        isSelected={isSelected}
                        isToday={isToday}
                        isWeekend={weekend}
                        isHovered={isHovered}
                        onDateClick={handleDateClick}
                        onDateMouseEnter={handleDateMouseEnter}
                        onDateMouseLeave={handleDateMouseLeave}
                      />
                    )
                  })}
                </div>
              </div>
            )
          })}
        </div>
      </div>
      {/* Î≤îÎ°Ä */}
      <Timeline2DLegend />
      {/* ÏÑ†ÌÉùÎêú ÎÇ†Ïßú Ï†ïÎ≥¥ */}
      <Timeline2DSelectedInfo selectedDate={selectedDate} />
    </div>
  )
}